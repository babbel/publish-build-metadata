#!/usr/bin/env ruby

require "optparse"
require "json"

options = {
  slices: [],
  sha: ENV["GITHUB_SHA"],
  branch: ENV["GITHUB_REF"].sub("refs/heads/", ""),
  commit_message_sha: ''
}

puts "Verifying default options:", JSON.pretty_generate(options)

OptionParser.new do |opts|
  opts.banner = "Usage: verify [options]"

  opts.on("-s", "--slices [SLICES]", Array) do |v|
    options[:slices] = v.sort
  end

  opts.on("-c", "--commit-sha [SHA]", String) do |v|
    options[:sha] = v
  end

  opts.on("-b", "--branch-name [BRANCH]", String) do |v|
    options[:branch] = v
  end

  opts.on("-m", "--commit-message-sha [COMMIT_MESSAGE_SHA]", String) do |v|
    options[:commit_message_sha] = v
  end
end.parse!

puts "Verifying provided options:", JSON.pretty_generate(options)

cmd = <<-CMD
aws dynamodb get-item --endpoint-url #{ENV["AWS_ENDPOINT_URL"]} \
                      --table-name metadata \
                      --region local \
                      --key '{"repository":{"S":"#{ENV["GITHUB_REPOSITORY"]}"},"commit_sha":{"S":"#{options[:sha]}"}}'
CMD

result = `#{cmd.strip}`.strip

raise "Missing entry in DynamoDB" if result.empty?

item = JSON.parse(result)

puts "Found item:", JSON.pretty_generate(item)

slices = item.dig("Item", "slices", "L")&.map { |s| s["S"] } || []

raise "Wrong slices in DynamoDB, expected: #{options[:slices].inspect}, got: #{slices.inspect}" if slices.sort != options[:slices]

unless options[:branch].empty?
  branch = item.dig("Item", "commit_branch", "S")

  raise "Wrong branch in DynamoDB, expected: #{options[:branch].inspect}, got: #{branch.inspect}" if branch != options[:branch]
end

unless options[:commit_message_sha].empty?
  expected_commit_message_sha = `git show --format='%s (%h)%n%b' --no-patch #{options[:commit_message_sha]}`.strip
  stored_commit_message_sha = item.dig("Item", "commit_message", "S")

  if stored_commit_message_sha != expected_commit_message_sha
    raise "Wrong commit_message_sha in DynamoDB, expected: #{expected_commit_message_sha}, got: #{stored_commit_message_sha}"
  end

  expected_commit_datetime = `git show -s --format='%ci' --no-patch #{options[:commit_message_sha]}`.strip
  stored_commit_datetime = item.dig("Item", "commit_datetime", "S")

  if stored_commit_datetime != expected_commit_datetime
    raise "Wrong commit_datetime in DynamoDB, expected: #{expected_commit_datetime}, got: #{stored_commit_datetime}"
  end
end

puts "All good!"
